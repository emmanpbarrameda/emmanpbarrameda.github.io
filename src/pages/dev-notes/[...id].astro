---
import { getCollection } from "astro:content";
import BlogPostShell from "../../components/blog/BlogPostShell.astro";

export async function getStaticPaths() {
  const posts = await getCollection("blog");

  return posts
    .filter((p) => (import.meta.env.PROD ? !p.data.draft : true))
    .map((post) => {
      const cleanId = post.id.replace(/\.(md|mdx)$/, "");
      return { params: { id: cleanId }, props: { post, cleanId } };
    });
}

type ReadOpts = { textWpm?: number; codeWeight?: number };

function estimateReadMinutes(markdown = "", { textWpm = 180, codeWeight = 0.35 }: ReadOpts = {}) {
  const codeBlocks = markdown.match(/```[\s\S]*?```|~~~[\s\S]*?~~~/g) ?? [];
  const codeWords = (
    codeBlocks
      .join(" ")
      .replace(/```|~~~/g, " ")
      .match(/\S+/g) ?? []
  ).length;

  let text = markdown.replace(/```[\s\S]*?```/g, " ").replace(/~~~[\s\S]*?~~~/g, " ");

  const inlineCodes = text.match(/`[^`]+`/g) ?? [];
  const inlineWords = (inlineCodes.join(" ").replace(/`/g, " ").match(/\S+/g) ?? []).length;
  text = text.replace(/`[^`]*`/g, " ");

  text = text
    .replace(/!\[([^\]]*)\]\([^)]+\)/g, " $1 ")
    .replace(/\[([^\]]+)\]\([^)]+\)/g, " $1 ")
    .replace(/<\/?[^>]+>/g, " ")
    .replace(/^[>#*+\-]+\s+/gm, " ")
    .replace(/\s+/g, " ")
    .trim();

  const textWords = (text.match(/\S+/g) ?? []).length;
  const effectiveWords = textWords + (codeWords + inlineWords) * codeWeight;

  return Math.max(1, Math.ceil(effectiveWords / textWpm));
}

const { post, cleanId } = Astro.props;
const { Content } = await post.render();

const base = import.meta.env.BASE_URL || "/";
const canonicalUrl = new URL(`${base}blog/${cleanId}/`, Astro.site).toString();

const readMinutes = estimateReadMinutes(post.body ?? "", { textWpm: 180, codeWeight: 0.35 });
---

<BlogPostShell title={post.data.title} description={post.data.description} pubDate={post.data.pubDate} tags={post.data.tags} cover={post.data.cover} url={canonicalUrl} readMinutes={readMinutes}>
  <Content />
</BlogPostShell>
